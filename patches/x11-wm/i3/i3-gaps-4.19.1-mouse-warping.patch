--- i3-4.19.1.orig/include/data.h
+++ i3-4.19.1/include/data.h
@@ -138,8 +138,9 @@
  * Mouse pointer warping modes.
  */
 typedef enum {
-    POINTER_WARPING_OUTPUT = 0,
-    POINTER_WARPING_NONE = 1
+    POINTER_WARPING_ALWAYS = 0,
+    POINTER_WARPING_OUTPUT = 1,
+    POINTER_WARPING_NONE = 2
 } warping_t;
 
 struct gaps_t {
--- i3-4.19.1.orig/src/commands.c
+++ i3-4.19.1/src/commands.c
@@ -1340,7 +1340,9 @@
             (!to_floating && current->type == CT_FLOATING_CON))
             continue;
 
-        con_activate_unblock(con_descend_focused(current));
+        Con *focus = con_descend_focused(current);
+        con_activate_unblock(focus);
+        x_set_warp_to(&(focus->rect));
         success = true;
         break;
     }
--- i3-4.19.1.orig/src/config_directives.c
+++ i3-4.19.1/src/config_directives.c
@@ -408,6 +408,8 @@
         config.mouse_warping = POINTER_WARPING_NONE;
     else if (strcmp(value, "output") == 0)
         config.mouse_warping = POINTER_WARPING_OUTPUT;
+    else if (strcmp(value, "always") == 0)
+        config.mouse_warping = POINTER_WARPING_ALWAYS;
 }
 
 CFGFUN(force_xinerama, const char *value) {
--- i3-4.19.1.orig/src/tree.c
+++ i3-4.19.1/src/tree.c
@@ -401,6 +401,7 @@
         return false;
     }
     con_activate(focused->parent);
+    x_set_warp_to(&(focused->parent->rect));
     return true;
 }
 
@@ -426,6 +427,7 @@
     }
 
     con_activate(next);
+    x_set_warp_to(&(next->rect));
     return true;
 }
 
@@ -621,7 +623,10 @@
     }
 
     workspace_show(con_get_workspace(next));
-    con_activate(con_descend_focused(next));
+
+    Con *focus = con_descend_focused(next);
+    con_activate(focus);
+    x_set_warp_to(&(focus->rect));
 }
 
 /*
--- i3-4.19.1.orig/src/x.c
+++ i3-4.19.1/src/x.c
@@ -1249,9 +1249,16 @@
             int mid_x = warp_to->x + (warp_to->width / 2);
             int mid_y = warp_to->y + (warp_to->height / 2);
 
-            Output *current = get_output_containing(pointerreply->root_x, pointerreply->root_y);
-            Output *target = get_output_containing(mid_x, mid_y);
-            if (current != target) {
+            bool warp_cursor = false;
+            if (config.mouse_warping == POINTER_WARPING_ALWAYS) {
+                warp_cursor = true;
+            } else {
+                Output *current = get_output_containing(pointerreply->root_x, pointerreply->root_y);
+                Output *target = get_output_containing(mid_x, mid_y);
+                warp_cursor = current != target;
+            }
+
+            if (warp_cursor) {
                 /* Ignore MotionNotify events generated by warping */
                 xcb_change_window_attributes(conn, root, XCB_CW_EVENT_MASK, (uint32_t[]){XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT});
                 xcb_warp_pointer(conn, XCB_NONE, root, 0, 0, 0, 0, mid_x, mid_y);
