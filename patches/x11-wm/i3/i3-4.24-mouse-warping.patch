Add option to always warp the mouse when focussing a different window

i3 has this functionality, but it's restricted to moving the mouse only when
switching between monitors. This feature is a mainstay in other window
managers, and I wonder why it isn't available in i3.

--- i3-4.24.orig/include/data.h
+++ i3-4.24/include/data.h
@@ -139,8 +139,9 @@
  * Mouse pointer warping modes.
  */
 typedef enum {
-    POINTER_WARPING_OUTPUT = 0,
-    POINTER_WARPING_NONE = 1
+    POINTER_WARPING_ALWAYS = 0,
+    POINTER_WARPING_OUTPUT = 1,
+    POINTER_WARPING_NONE = 2
 } warping_t;
 
 struct gaps_t {
--- i3-4.24.orig/src/commands.c
+++ i3-4.24/src/commands.c
@@ -1422,7 +1422,9 @@
             continue;
         }
 
-        con_activate_unblock(con_descend_focused(current));
+        Con *focus = con_descend_focused(current);
+        con_activate_unblock(focus);
+        x_set_warp_to(&(focus->rect));
         success = true;
         break;
     }
--- i3-4.24.orig/src/config_directives.c
+++ i3-4.24/src/config_directives.c
@@ -447,6 +447,8 @@
         config.mouse_warping = POINTER_WARPING_NONE;
     } else if (strcmp(value, "output") == 0) {
         config.mouse_warping = POINTER_WARPING_OUTPUT;
+    } else if (strcmp(value, "always") == 0) {
+        config.mouse_warping = POINTER_WARPING_ALWAYS;
     }
 }
 
--- i3-4.24.orig/src/tree.c
+++ i3-4.24/src/tree.c
@@ -404,6 +404,7 @@
         return false;
     }
     con_activate(focused->parent);
+    x_set_warp_to(&(focused->parent->rect));
     return true;
 }
 
@@ -430,6 +431,7 @@
     }
 
     con_activate(next);
+    x_set_warp_to(&(next->rect));
     return true;
 }
 
@@ -630,7 +632,10 @@
     }
 
     workspace_show(con_get_workspace(next));
-    con_activate(con_descend_focused(next));
+
+    Con *focus = con_descend_focused(next);
+    con_activate(focus);
+    x_set_warp_to(&(focus->rect));
 }
 
 /*
--- i3-4.24.orig/src/x.c
+++ i3-4.24/src/x.c
@@ -1364,9 +1364,16 @@
             int mid_x = warp_to->x + (warp_to->width / 2);
             int mid_y = warp_to->y + (warp_to->height / 2);
 
-            Output *current = get_output_containing(pointerreply->root_x, pointerreply->root_y);
-            Output *target = get_output_containing(mid_x, mid_y);
-            if (current != target) {
+            bool warp_cursor = false;
+            if (config.mouse_warping == POINTER_WARPING_ALWAYS) {
+                warp_cursor = true;
+            } else {
+                Output *current = get_output_containing(pointerreply->root_x, pointerreply->root_y);
+                Output *target = get_output_containing(mid_x, mid_y);
+                warp_cursor = current != target;
+            }
+
+            if (warp_cursor) {
                 /* Ignore MotionNotify events generated by warping */
                 xcb_change_window_attributes(conn, root, XCB_CW_EVENT_MASK, (uint32_t[]){XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT});
                 xcb_warp_pointer(conn, XCB_NONE, root, 0, 0, 0, 0, mid_x, mid_y);
